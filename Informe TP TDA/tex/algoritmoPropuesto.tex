\section{Algoritmo Propuesto}

A partir del analisis llevado a cabo en la sección previa, obtuvimos la ecucación de recurrencia, que nos aproxima considerablemente a cómo sería la implementación de un algoritmo por programación dinámica que obtenga la solución óptima, ya que, la misma nos explicita la forma en la que la información relativa a las soluciones óptimas de los problemas más pequeños ($OP(k)$, $k<n$) se usan para construir la solución al problema actual $OP(n)$.\\

Para plasmar la lógica de la ecucación de recurrencia en código, en nuestro equipo decidimos realizar la implementación haciendo uso de un enfoque $bottom-up$, ya que este permite visualzar de forma más notoria la implementación y uso de memoization, que es el almacenamiento de los resultados de cálculos previos para evitar tener que recalcularlos. Esta técnica será de mucha utilidad para optimizar y llevar a cabo tanto la reconstrucción de las acciones que se realizan en la estrategia como para obtener el valor de la cantidad de bajas máxima.

Habiendo ya esclarecido el porqué optamos por implementar un algoritmo bottom-up, y mecionado brevemente el papel de la memorización de datos relativos a la solucion de los subproblemas, pasamos a mencionar cuál es la información de está índole que nos pareció relevante memorizar y el porqué.\\

\textit{*En lo que sigue llamaremos ``mejor baja''  al valor de la máxima cantidad posible de bajas de dicho problema, también...}
\begin{itemize}
    \item Para hallar la mejor baja respectiva al problema de tamaño $n$: $OP(n)$ necesitamos saber el valor de las mejores bajas de los subproblemas previos: $OP(k)$, y como en un caso general no es posible poder predecir cuales de estos valores ya no serán útiles para problemas de mayor tamaño, entonces vimos necesario el "memorizar" todas la totalidad de esos valores de los subproblemas. \\
    Esto se refleja en nuestro código en la creación y actualización de los valores del arreglo $OP$, que guarda exclusivamente el \textbf{valor de las mejores bajas obtenibles en dicho subproblema}.  
    
    \item Dado que para la construcción de la solución de un problema de tamaño $n$ cualquiera diferente de cero nos vemos en la necesidad de evaluar cúal de todas las soluciones previas (de menor tamaño) termina componiendo la mejor solución al problema actual y al final elegimos un un subproblema $k$ que es el que logra esta maximización, vimos por conveniente recordar este dato.
    Pues, para la reconstrucción de la estrategia necesaria para alcanzar esta solución óptima, resulta el punto de partida el tener en cuenta que una solución óptima siempre considera que es conveniente atacar en el último minuto (respectivo al tamaño del subproblema).Entonces, resulta evidente que necesitamos saber cuál es la solución óptima respectiva a un subproblema que termina componiendo la solución a este. 
    En este contexto resulta una optimización significativa para la reconstrucción el saber \textbf{cuál es la solución, correspondiente a un subproblema previo, que se decidió y corroboró como la mejor composición al problema que consideramos}.
    
    Esta observación se refleja en nuestro código en la creación y asignación de los valores del arreglo $prev\_atack$ con el cual resulta una tarea poco compleja el llevar a cabo la reconstrucción, resultado ser una tarea lineal respecto a la cantidad de minutos $n$. 
    \textit{De querer visualizar cómo reconstruimos la estrategia respectiva a la solución óptima de un problema véanse las funciones $reconstruction$ y $recursive\_reconstruction$ del archivo $tp.py$ ubicado en el directorio Codigo fuente del repositorio} 
\end{itemize}


\subsection{Código}
Una vez expuestas las razones de porqué decidimos almacenar ciertas informaciones relativas a las soluciones óptimas de cada subproblema, así como el porqué del enfoque mediante cual construimos nuestro algoritmo, pasamos a presentar finalmente el algoritmo propuesto.

\begin{lstlisting}[language=Python]
def kills_and_strategy(n , x , f):
    OP = [0] * (n + 1)
    prev_atack = [0] * (n)
    for i in range(1 , n + 1):
        for prev in range(i):
            bajas = min(x[i - 1] , f[i - prev - 1]) + OP[prev]
            if bajas >= OP[i]:
                OP[i] = bajas
                prev_atack[i - 1] = prev
    return OP[-1], reconstruction(prev_atack)
\end{lstlisting}

Cabe mencionar que este es el algoritmo propuesto por programación dinámica, lo cual, no significa que esta sea la versión final del algoritmo implementado en nuestro programa, ya que, posteriormente, en la sección de variabilidad de datos mecionamos optimizaciones que encontramos factibles, así cómo su integración a nuestro algoritmo como se mecionó previamente.  


Respecto al algoritmo de reconstrucción, dados los minutos en los que realizamos un ataque tomamos como base un arreglo de acciones que conforman nuestra estrategía. Inicialmente este será de unicamente cargas y mientras retrocedemos en los reinicios indicados en los dados guardados (partiendo desde el reinicio del minuto final) iremos editando dichas acciones para que reflejen los puntos de reinicio de energía que efectivamente se toman en cuenta para la estratégia final. 

\subsection{Complejidad del algoritmo}\label{sec:complexity}

\subsubsection{La complejidad temporal del programa  es  $\mathcal{O}(n^{2})$ }
\paragraph{Justificación:}\newline
\textbf{Respecto al algoritmo de programación dinámica:}
Consideramos (y calculamos efectivamente) $j$ posibles opciones de energía con las que podemos llegar al minuto actual: $i$ (de forma que $0<j<i$). Es que en el peor de los casos, cuando $i=n$, debemos evaluar $n$ opciones de energía, generalizando este caso para cada iteración es que llegamos a la complejidad temporal propuesta. Si queremos ser minuciosos, previamente en el análisis de la forma y composición del problema (vease \ref{eq:suamtoriaOpciones}) podemos verificar que aproximadamente en cada iteración analizamos n opciones (aunque en la realidad $n$ dependa de la iteración en la que nos encontramos, pero este nunca será superior a la duración de la batalla entera).

En resumidas cuentas:

\begin{equation*}
    \mathcal{T}(n)=\mathcal{O}(\sum_{i=1}^{n} i )=\mathcal{O}(\frac{n(n+1)}{2})=\mathcal{O}(n^2)
\end{equation*}
\textbf{Respecto a la complejidad del algoritmo de reconstrucción: } Dada la estrategia de reconstrucción ya mencionada, existe la posibilidad (en el peor de los casos) de que nuestro algoritmo tarde tiempo lineal. Es decir, tomando como cota la situación en la que siempre debamos atacar, la complejidad resulta $\mathcal{O}(n)$ que en realidad no emperora la complejidad del algoritmo por porgramación dinámica. 



\textbf{La complejidad espacial del algoritmo propuesto es  $\mathcal{O}(n)$ } (\textit{sea n la duración de la batalla})
\paragraph{Justificación:} Nuestro algoritmo, como uno basado en un diseño por programación dinámica, almacena los resultados de los subproblemas para evitar recalculos en el futuro. En nuestro caso, los datos memorizados son las eliminaciones óptimas si la duración de la batalla fuese $i$ (donde $0<i<n+1$) y el minuto de reinicio más reciente ante el ataque en el minuto $i$ (que directamente nos indica con cuánta energía contamos). Es decir, la complejidad espacial dados 2 datos que guardamos para cada iteración, es:

\begin{equation*}
    \mathcal{T}(n)=\mathcal{O}(2\times n)=\mathcal{O}(n)
\end{equation*}
 


